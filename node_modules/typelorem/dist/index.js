"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const caller_1 = __importDefault(require("./caller"));
const generateSchema_1 = require("./generateSchema");
const KEY = "typelorem";
const host = "http://typeloremapi-env-1.eba-dg35fbvk.eu-central-1.elasticbeanstalk.com/";
const post = (symbolName, schema, repeat) => __awaiter(void 0, void 0, void 0, function* () {
    const api = `${host}?key=${KEY}`;
    const result = yield fetch(api, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            schema: {
                [symbolName]: schema,
            },
            repeat,
        }),
    });
    return yield result.json();
});
const postMany = (symbolNames, schemas, repeat) => __awaiter(void 0, void 0, void 0, function* () {
    const api = `${host}many?key=${KEY}`;
    const schemaObjectList = symbolNames.reduce((acc, symbolName, index) => {
        return [...acc, { [symbolName]: schemas[index] }];
    }, []);
    const result = yield fetch(api, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            schemas: schemaObjectList,
            repeat,
        }),
    });
    return yield result.json();
});
class Schema {
    constructor(symbolName, schema) {
        this.symbolName = symbolName;
        this.schema = schema;
        this.error = undefined;
    }
}
class TypeLorem {
    constructor() {
        this.schemas = [];
        this.symbolNames = [];
        this.fileName = (0, caller_1.default)();
    }
    schema(...symbolNames) {
        this.symbolNames = symbolNames;
        for (const symbolName of this.symbolNames) {
            const data = (0, generateSchema_1.generateSchema)(symbolName, this.fileName);
            const schema = new Schema(symbolName, data);
            schema.schema && this.schemas.push(schema.schema);
        }
        return {
            make: (repeat) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const fetchJsonLorem = () => __awaiter(this, void 0, void 0, function* () {
                        return yield postMany(this.symbolNames, this.schemas, repeat);
                    });
                    return yield fetchJsonLorem();
                }
                catch (error) {
                    this.error = error;
                }
            }),
        };
    }
    _schema(symbolName) {
        const data = (0, generateSchema_1.generateSchema)(symbolName, this.fileName);
        return new Schema(symbolName, data);
    }
    make(symbolName, repeat) {
        const fetchJsonLorem = (schema) => __awaiter(this, void 0, void 0, function* () {
            return yield post(symbolName, schema, repeat);
        });
        const schema = this._schema(symbolName);
        return fetchJsonLorem(schema.schema);
    }
}
TypeLorem.apiKey = KEY;
exports.default = TypeLorem;
//# sourceMappingURL=index.js.map